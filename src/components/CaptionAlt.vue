<template>
  <v-card class="d-flex flex-row mx-3 p-1 caption" :class="{ open }">
    <v-row align="center" class="mx-1">
      <v-col cols="1" id="voteButtons">
        <v-row :title="edit.panoptoGenerated ? 'Cannot vote on autogenerated caption' : 'Like'">
          <v-btn title="Like" icon small @click="vote('upvote')" :disabled="edit.panoptoGenerated">
            <v-icon v-bind:class="{ iconHighlight: edit.upvoted }" class="material-icons">
              arrow_upward
            </v-icon>
          </v-btn>
        </v-row>
        <v-row>
          <!-- Need to refresh once the user votes -->
          <div id="votes">{{ edit.votes }}</div>
        </v-row>
        <v-row :title="edit.panoptoGenerated ? 'Cannot vote on autogenerated caption' : 'Dislike'">
          <v-btn
            title="Dislike"
            icon
            small
            @click="vote('downvote')"
            :disabled="edit.panoptoGenerated"
          >
            <!-- edit.upvoted can be null so need to check if false, not just !edit.upvoted -->
            <v-icon v-bind:class="{ iconHighlight: edit.upvoted === false }" class="material-icons">
              arrow_downward
            </v-icon>
          </v-btn>
        </v-row>
      </v-col>
      <v-col class="captionText" @click="!open && toggleShowEdits()">
        <v-textarea
          id="captionField"
          ref="captionField"
          hide-details="true"
          outlined
          v-model="edited"
          :disabled="!open"
          @focus="isEditing = true"
          @blur="isEditing = false"
          @keydown="handleBubble"
          @keydown.enter="toggleEditState()"
          :class="{ largeFont: isLarge }"
          :rows="2"
          :no-resize="true"
          :auto-grow="false"
        >
        </v-textarea>
        <div class="submitHint" v-if="isEditing">
          <div class="card">
            Submitting as {{ user.firstName }} ({{ user.upi }}) - anonymous to classmates
          </div>
        </div>
        <!-- @keydown.space="handleBubble"
          @keydown.left="handleBubble"
          @keydown.right="handleBubble"
          @keydown.up="handleBubble"
          @keydown.down="handleBubble" -->
      </v-col>
      <v-col cols="1" id="captionActions" justify="end">
        <v-btn
          title="Show more..."
          v-if="!open && index == 0"
          icon
          small
          @click="toggleShowEdits()"
        >
          <!-- index used here; if first Cap - display the dropdown -->
          <v-icon class="material-icons"> view_list </v-icon>
        </v-btn>
        <v-btn
          title="Suggest Changes"
          v-else-if="!edit.isAuthor"
          fab
          small
          @click="toggleEditState()"
          :color="isEditing ? 'primary' : ''"
        >
          <v-icon class="material-icons" v-if="isEdited"> save </v-icon>
          <v-icon class="material-icons" v-else> create </v-icon>
        </v-btn>
        <v-btn v-if="edit.isAuthor" title="Delete" icon small @click="report()">
          <v-icon class="material-icons"> delete </v-icon>
        </v-btn>
        <div
          v-else
          :title="edit.panoptoGenerated ? 'Cannot report autogenerated caption' : 'Report'"
        >
          <v-btn title="Report" icon small @click="report()" :disabled="edit.panoptoGenerated">
            <v-icon class="material-icons" v-bind:class="{ iconHighlight: edit.reported }">
              flag
            </v-icon>
          </v-btn>
        </div>
      </v-col>
    </v-row>
  </v-card>
</template>

<script>
export default {
  props: {
    index: Number,
    edit: Object,
    open: Boolean,
    isLarge: Boolean,
    user: Object,
  },
  data() {
    return {
      edited: this.edit.body,
      setDisabled: false,
      isEditing: false,
    };
  },
  name: "CaptionAlt",
  computed: {
    // this function watches the setDisabled changes.
    setDisabledCall() {
      return this.setDisabled;
    },
    isEdited() {
      return this.edited !== this.edit.body;
    },
  },
  watch: {
    edit(val) {
      this.edited = val.body;
    },
  },

  methods: {
    vote(voteMethod) {
      this.$emit("set-vote", { edit: this.edit, vote: voteMethod });
    },
    report() {
      this.$emit("set-report", { edit: this.edit, report: !this.edit.reported });
    },
    getFontSize() {
      return this.textSize;
    },
    toggleShowEdits() {
      // camelcasing doesn't work with events: https://vuejs.org/v2/guide/components-custom-events.html?fbclid=IwAR2IBgB858gqdXbRwSwGpVTtSdAO9obkiJxSz1E31jHZSl6abIjLRrP2YPQ
      this.$emit("show-edits");
    },
    toggleEditState() {
      if (this.isEdited) {
        this.$refs.captionField.blur();
        this.$emit("save-caption", { body: this.edited });
      } else {
        this.$refs.captionField.focus();
      }
    },
    handleBubble(event) {
      console.log("Attempting prevention of propogration");
      // Prevent propagating up to the video player (which would cause play/pause or skipping)
      event.stopPropagation();
    },
  },
};
</script>
<style>
#votes {
  margin-left: 0.6rem;
}

.largeFont {
  font-size: 1.6em !important;
}

.captionText .theme--dark.v-input--is-disabled textarea {
  color: #fff !important;
}

.captionText .theme--light.v-input--is-disabled textarea {
  color: #000 !important;
}

.captionText .v-text-field > .v-input__control > .v-input__slot > .v-text-field__slot {
  flex-wrap: wrap;
  align-content: center;
}

textarea#captionField {
  text-align: center;
  font-size: 1.3em;
  margin-top: 0;
}
</style>

<style scoped>
.iconHighlight {
  color: #f0c933 !important;
}

.hidden {
  visibility: hidden;
  opacity: 0;
}

.caption {
  /* Total height: 7.6rem */
  height: 5rem;
  padding: 0.8rem;
  margin: 1rem;
}

#captionActions,
#voteButtons {
  opacity: 0.1;
  transition: 0.4s ease opacity;
}

.caption:hover #captionActions,
.caption:hover #voteButtons,
.caption.open #captionActions,
.caption.open #voteButtons {
  opacity: 1;
}

.submitHint {
  position: absolute;
  top: 100%;
  left: 0;
  right: 0;
  display: block;
  z-index: 10;
  transform: translateY(-50%);
  user-select: none;
  pointer-events: none;
}

.submitHint .card {
  background: #30733f;
  border-radius: 3px;
  display: inline-block;
  padding: 0 0.5rem;
}
</style>
